name: pitot CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  # Nightly builds disabled to reduce CI costs
  # schedule:
  #   # Run nightly builds at 2 AM UTC
  #   - cron: '0 2 * * *'

env:
  # Customize the CMake build type here (Release, Debug, RelWithDebInfo, etc.)
  BUILD_TYPE: Release

jobs:
  # Code formatting and basic checks
  format-check:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
      with:
        submodules: recursive
        token: ${{ secrets.SUBMODULE_TOKEN }}
    
    - name: Debug - Check submodules
      run: |
        echo "Checking if submodules were checked out..."
        echo "Git submodule status:"
        git submodule status || echo "git submodule status failed"
        echo "Directory listing:"
        ls -la deps/ || echo "deps directory not found"
        if [ -d "deps/Mutex" ]; then
          echo "✅ Mutex submodule found"
          ls -la deps/Mutex/CMakeLists.txt || echo "Mutex CMakeLists.txt not found"
        else
          echo "❌ Mutex submodule missing"
        fi
        if [ -d "deps/Logger" ]; then
          echo "✅ Logger submodule found"  
          ls -la deps/Logger/CMakeLists.txt || echo "Logger CMakeLists.txt not found"
        else
          echo "❌ Logger submodule missing"
        fi
    
    - name: Install clang-format
      run: |
        sudo apt-get update
        sudo apt-get install -y clang-format-14
    
    - name: Check code formatting
      run: |
        find include Tests -name "*.cpp" -o -name "*.cxx" -o -name "*.h" -o -name "*.hpp" | \
        xargs clang-format-14 --dry-run --Werror

  # Multi-platform build matrix - OPTIMIZED FOR COST
  build:
    needs: format-check
    strategy:
      fail-fast: false
      matrix:
        include:
          # Essential builds only - reduced from 54 to 6 jobs
          - os: ubuntu-latest
            compiler: gcc
            cxx_standard: 17
            build_type: Release
            name: "Linux GCC C++17 Release"
          - os: ubuntu-latest
            compiler: gcc
            cxx_standard: 17
            build_type: Debug
            name: "Linux GCC C++17 Debug"
          - os: ubuntu-latest
            compiler: clang
            cxx_standard: 17
            build_type: Release
            name: "Linux Clang C++17 Release"
          # Only test Windows/macOS on main branch or releases
          - os: windows-latest
            compiler: msvc
            cxx_standard: 17
            build_type: Release
            name: "Windows MSVC C++17 Release"
            condition: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/')
          - os: macos-latest
            compiler: clang
            cxx_standard: 17
            build_type: Release
            name: "macOS Clang C++17 Release"
            condition: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/')
          # Coverage build (Linux only)
          - os: ubuntu-latest
            compiler: gcc
            cxx_standard: 17
            build_type: Debug
            name: "Coverage Build"
            enable_coverage: true

    runs-on: ${{ matrix.os }}
    
    # Skip expensive builds on feature branches
    if: |
      matrix.condition == '' || 
      github.ref == 'refs/heads/main' || 
      startsWith(github.ref, 'refs/tags/') ||
      github.event_name == 'schedule'

    steps:
    - uses: actions/checkout@v4
      with:
        submodules: recursive
        token: ${{ secrets.SUBMODULE_TOKEN }}

    - name: Debug - Check submodules
      run: |
        echo "Checking if submodules were checked out..."
        echo "Git submodule status:"
        git submodule status || echo "git submodule status failed"
        echo "Directory listing:"
        ls -la deps/ || echo "deps directory not found"
        if [ -d "deps/Mutex" ]; then
          echo "✅ Mutex submodule found"
          ls -la deps/Mutex/CMakeLists.txt || echo "Mutex CMakeLists.txt not found"
        else
          echo "❌ Mutex submodule missing"
        fi
        if [ -d "deps/Logger" ]; then
          echo "✅ Logger submodule found"  
          ls -la deps/Logger/CMakeLists.txt || echo "Logger CMakeLists.txt not found"
        else
          echo "❌ Logger submodule missing"
        fi

    - name: Set up build environment (Linux)
      if: runner.os == 'Linux'
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential cmake
        if [ "${{ matrix.compiler }}" = "clang" ]; then
          sudo apt-get install -y clang-14 clang++-14
          echo "CC=clang-14" >> $GITHUB_ENV
          echo "CXX=clang++-14" >> $GITHUB_ENV
        elif [ "${{ matrix.compiler }}" = "gcc" ]; then
          sudo apt-get install -y gcc-11 g++-11
          echo "CC=gcc-11" >> $GITHUB_ENV
          echo "CXX=g++-11" >> $GITHUB_ENV
        fi

    - name: Set up build environment (macOS)
      if: runner.os == 'macOS'
      run: |
        brew install cmake
        if [ "${{ matrix.compiler }}" = "gcc" ]; then
          brew install gcc@11
          echo "CC=gcc-11" >> $GITHUB_ENV
          echo "CXX=g++-11" >> $GITHUB_ENV
        fi

    - name: Set up build environment (Windows)
      if: runner.os == 'Windows'
      uses: microsoft/setup-msbuild@v1.3

    - name: Configure CMake
      run: |
        cmake -B ${{github.workspace}}/build \
          -DCMAKE_BUILD_TYPE=${{ matrix.build_type }} \
          -DPITOT_CXX_STANDARD=${{ matrix.cxx_standard }} \
          -DBUILD_TESTING=ON \
          -DENABLE_COVERAGE=${{ matrix.enable_coverage == true }} \
          -G "Unix Makefiles"

    - name: Build
      run: cmake --build ${{github.workspace}}/build --config ${{ matrix.build_type }} --parallel

    - name: Test
      working-directory: ${{github.workspace}}/build
      run: ctest --build-config ${{ matrix.build_type }} --output-on-failure --parallel

    - name: Generate coverage report
      if: matrix.enable_coverage == true
      working-directory: ${{github.workspace}}/build
      run: |
        sudo apt-get install -y lcov
        make coverage

    - name: Upload coverage to Codecov
      if: matrix.enable_coverage == true
      uses: codecov/codecov-action@v3
      with:
        directory: ${{github.workspace}}/build/coverage
        fail_ci_if_error: false

  # Static analysis - only on main branch and PRs to main
  static-analysis:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.base_ref == 'main' || startsWith(github.ref, 'refs/tags/')
    steps:
    - uses: actions/checkout@v4
      with:
        submodules: recursive
        token: ${{ secrets.SUBMODULE_TOKEN }}

    - name: Install analysis tools
      run: |
        sudo apt-get update
        sudo apt-get install -y clang-tidy-14 cppcheck build-essential cmake

    - name: Configure CMake with static analysis
      run: |
        cmake -B ${{github.workspace}}/build \
          -DCMAKE_BUILD_TYPE=Debug \
          -DENABLE_CLANG_TIDY=ON \
          -DENABLE_CPPCHECK=ON \
          -DBUILD_TESTING=OFF \
          -G "Unix Makefiles"

    - name: Run static analysis
      run: |
        # Build first to generate compile_commands.json
        cmake --build build --parallel
        
        # Run clang-tidy if enabled
        if [ "$ENABLE_CLANG_TIDY" = "ON" ]; then
          find include -name "*.h" -o -name "*.hpp" | \
          xargs clang-tidy-14 \
            --checks="-*,bugprone-*,cert-*,clang-analyzer-*,cppcoreguidelines-*,google-*,hicpp-*,misc-*,modernize-*,performance-*,portability-*,readability-*,-readability-magic-numbers,-cppcoreguidelines-avoid-magic-numbers,-google-readability-todo,-hicpp-signed-bitwise,-modernize-use-trailing-return-type" \
            --extra-arg=-std=c++17 \
            --extra-arg=-I/usr/include/c++/9 \
            --extra-arg=-I/usr/include/x86_64-linux-gnu/c++/9 \
            --extra-arg=-I/usr/include/c++/9/backward \
            --header-filter='include/.*' \
            -p build || true
        fi

  # Sanitizer builds - only essential ones, only on main
  sanitizers:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || startsWith(github.ref, 'refs/tags/')
    strategy:
      matrix:
        sanitizer: [asan]  # Only address sanitizer, most important one
    steps:
    - uses: actions/checkout@v4
      with:
        submodules: recursive
        token: ${{ secrets.SUBMODULE_TOKEN }}

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential cmake clang-14

    - name: Configure CMake with sanitizers
      run: |
        cmake -B ${{github.workspace}}/build \
          -DCMAKE_BUILD_TYPE=Debug \
          -DCMAKE_C_COMPILER=clang-14 \
          -DCMAKE_CXX_COMPILER=clang++-14 \
          -DENABLE_${{ matrix.sanitizer == 'asan' && 'ASAN' || matrix.sanitizer == 'tsan' && 'TSAN' || 'UBSAN' }}=ON \
          -DBUILD_TESTING=ON \
          -G "Unix Makefiles"

    - name: Build with sanitizers
      run: cmake --build ${{github.workspace}}/build --parallel

    - name: Test with sanitizers
      working-directory: ${{github.workspace}}/build
      run: ctest --output-on-failure --parallel

  # Package generation - only on main branch
  package:
    needs: [build, static-analysis]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v4
      with:
        submodules: recursive
        token: ${{ secrets.SUBMODULE_TOKEN }}

    - name: Install packaging dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential cmake rpm

    - name: Configure CMake for packaging
      run: |
        cmake -B ${{github.workspace}}/build \
          -DCMAKE_BUILD_TYPE=Release \
          -DBUILD_TESTING=OFF \
          -G "Unix Makefiles"

    - name: Build
      run: cmake --build ${{github.workspace}}/build --parallel

    - name: Create packages
      working-directory: ${{github.workspace}}/build
      run: |
        cpack -G "DEB;RPM;TGZ"

    - name: Validate packages
      working-directory: ${{github.workspace}}/build
      run: |
        # Simple package validation - check that files exist and are not empty
        for pkg in *.deb *.rpm *.tar.gz; do
          if [ -f "$pkg" ]; then
            echo "Found package: $pkg"
            ls -lh "$pkg"
            if [ ! -s "$pkg" ]; then
              echo "Error: Package $pkg is empty"
              exit 1
            fi
          fi
        done
        echo "Package validation completed"

    - name: Upload packages
      uses: actions/upload-artifact@v3
      with:
        name: pitot-packages
        path: |
          ${{github.workspace}}/build/*.deb
          ${{github.workspace}}/build/*.rpm
          ${{github.workspace}}/build/*.tar.gz

  # Performance benchmarks - only on main branch, not every push
  benchmarks:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - uses: actions/checkout@v4
      with:
        submodules: recursive
        token: ${{ secrets.SUBMODULE_TOKEN }}

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential cmake

    - name: Configure CMake for benchmarks
      run: |
        cmake -B ${{github.workspace}}/build \
          -DCMAKE_BUILD_TYPE=Release \
          -DBUILD_TESTING=ON \
          -G "Unix Makefiles"

    - name: Build
      run: cmake --build ${{github.workspace}}/build --parallel

    - name: Run performance tests
      working-directory: ${{github.workspace}}/build
      run: |
        # Run performance tests if they exist
        if ctest -N | grep -q "Performance"; then
          ctest -R "Performance" --output-on-failure
        else
          echo "No performance tests found, skipping"
        fi

    - name: Store benchmark results
      if: github.event_name == 'push' && github.ref == 'refs/heads/main'
      run: |
        # Store benchmark results as artifacts instead of using benchmark action
        echo "Benchmark results stored in build directory"